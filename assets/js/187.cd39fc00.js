(window.webpackJsonp=window.webpackJsonp||[]).push([[187],{541:function(e,t,a){"use strict";a.r(t);var n=a(0),r=Object(n.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"chapter-5-generics（泛型）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chapter-5-generics（泛型）","aria-hidden":"true"}},[e._v("#")]),e._v(" Chapter 5. Generics（泛型）")]),e._v(" "),a("h3",{attrs:{id:"item-30-favor-generic-methods（优先使用泛型方法）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#item-30-favor-generic-methods（优先使用泛型方法）","aria-hidden":"true"}},[e._v("#")]),e._v(" Item 30: Favor generic methods（优先使用泛型方法）")]),e._v(" "),a("p",[e._v("Just as classes can be generic, so can methods. Static utility methods that operate on parameterized types are usually generic. All of the “algorithm” methods in Collections (such as binarySearch and sort) are generic.")]),e._v(" "),a("p",[e._v("类可以是泛型的，方法也可以是泛型的。操作参数化类型的静态实用程序方法通常是泛型的。Collections 类中的所有「算法」方法（如 binarySearch 和 sort）都是泛型的。")]),e._v(" "),a("p",[e._v("Writing generic methods is similar to writing generic types. Consider this deficient（adj. 不足的；有缺陷的；不充分的） method, which returns the union of two sets:")]),e._v(" "),a("p",[e._v("编写泛型方法类似于编写泛型类型。考虑这个有缺陷的方法，它返回两个集合的并集：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Uses raw types - unacceptable! (Item 26)\npublic static Set union(Set s1, Set s2) {\n    Set result = new HashSet(s1);\n    result.addAll(s2);\n    return result;\n}\n")])])]),a("p",[e._v("This method compiles but with two warnings:")]),e._v(" "),a("p",[e._v("该方法可进行编译，但有两个警告：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Union.java:5: warning: [unchecked] unchecked call to\nHashSet(Collection<? extends E>) as a member of raw type HashSet\n        Set result = new HashSet(s1);\n                      ^\n\nUnion.java:6: warning: [\nunchecked] unchecked call to\naddAll(Collection<? extends E>) as a member of raw type Set\n        result.addAll(s2);\n                      ^\n")])])]),a("p",[e._v("To fix these warnings and make the method typesafe, modify its declaration to declare a type parameter representing the element type for the three sets (the two arguments and the return value) and use this type parameter throughout the method. "),a("strong",[e._v("The type parameter list, which declares the type parameters, goes between a method’s modifiers and its return type.")]),e._v(" In this example, the type parameter list is "),a("code",[e._v("<E>")]),e._v(", and the return type is "),a("code",[e._v("Set<E>")]),e._v(". The naming conventions for type parameters are the same for generic methods and generic types (Items 29, 68):")]),e._v(" "),a("p",[e._v("要修复这些警告并使方法类型安全，请修改其声明，以声明表示三个集合（两个参数和返回值）的元素类型的类型参数，并在整个方法中使用该类型参数。类型参数列表声明类型参数，它位于方法的修饰符与其返回类型之间。在本例中，类型参数列表为 "),a("code",[e._v("<E>")]),e._v("，返回类型为 "),a("code",[e._v("Set<E>")]),e._v("。类型参数的命名约定与泛型方法和泛型类型的命名约定相同（Item-29、Item-68）:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Generic method\npublic static <E> Set<E> union(Set<E> s1, Set<E> s2) {\n    Set<E> result = new HashSet<>(s1);\n    result.addAll(s2);\n    return result;\n}\n")])])]),a("p",[e._v("At least for simple generic methods, that’s all there is to it. This method compiles without generating any warnings and provides type safety as well as ease of use. Here’s a simple program to exercise the method. This program contains no casts and compiles without errors or warnings:")]),e._v(" "),a("p",[e._v("至少对于简单的泛型方法，这就是（要注意细节的）全部。该方法编译时不生成任何警告，并且提供了类型安全性和易用性。这里有一个简单的程序来演示。这个程序不包含转换，编译时没有错误或警告：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// Simple program to exercise generic method\npublic static void main(String[] args) {\n    Set<String> guys = Set.of("Tom", "Dick", "Harry");\n    Set<String> stooges = Set.of("Larry", "Moe", "Curly");\n    Set<String> aflCio = union(guys, stooges);\n    System.out.println(aflCio);\n}\n')])])]),a("p",[e._v("When you run the program, it prints [Moe, Tom, Harry, Larry, Curly, Dick]. (The order of the elements in the output is implementation-dependent.)")]),e._v(" "),a("p",[e._v("当你运行程序时，它会打印出 [Moe, Tom, Harry, Larry, Curly, Dick]。（输出元素的顺序可能不同）。")]),e._v(" "),a("p",[e._v("A limitation of the union method is that the types of all three sets (both input parameters and the return value) have to be exactly the same. You can make the method more flexible by using bounded wildcard types (Item 31).")]),e._v(" "),a("p",[e._v("union 方法的一个限制是，所有三个集合（输入参数和返回值）的类型必须完全相同。你可以通过使用有界通配符类型（Item-31）使方法更加灵活。")]),e._v(" "),a("p",[e._v("On occasion, you will need to create an object that is immutable but applicable to many different types. Because generics are implemented by erasure (Item 28), you can use a single object for all required type parameterizations, but you need to write a static factory method to repeatedly dole out the object for each requested type parameterization. This pattern, called the generic singleton factory, is used for function objects (Item 42) such as Collections.reverseOrder, and occasionally for collections such as Collections.emptySet.")]),e._v(" "),a("p",[e._v("有时，你需要创建一个对象，该对象是不可变的，但适用于许多不同类型。因为泛型是由擦除（Item-28）实现的，所以你可以为所有需要的类型参数化使用单个对象，但是你需要编写一个静态工厂方法，为每个请求的类型参数化重复分配对象。这种模式称为泛型单例工厂，可用于函数对象（Item-42），如 Collections.reverseOrder，偶尔也用于集合，如 Collections.emptySet。")]),e._v(" "),a("p",[e._v("Suppose that you want to write an identity function dispenser. The libraries provide Function.identity, so there’s no reason to write your own (Item 59), but it is instructive. It would be wasteful to create a new identity function object time one is requested, because it’s stateless. If Java’s generics were reified, you would need one identity function per type, but since they’re erased a generic singleton will suffice. Here’s how it looks:")]),e._v(" "),a("p",[e._v("假设你想要编写一个恒等函数分发器。这些库提供 Function.identity，所以没有理由编写自己的库（Item-59），但是它很有指导意义。在请求标识函数对象时创建一个新的标识函数对象是浪费时间的，因为它是无状态的。如果 Java 的泛型被具体化了，那么每个类型都需要一个标识函数，但是由于它们已经被擦除，一个泛型单例就足够了。它是这样的：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// Generic singleton factory pattern\nprivate static UnaryOperator<Object> IDENTITY_FN = (t) -> t;\n\n@SuppressWarnings("unchecked")\npublic static <T> UnaryOperator<T> identityFunction() {\n    return (UnaryOperator<T>) IDENTITY_FN;\n}\n')])])]),a("p",[e._v("The cast of IDENTITY_FN to ("),a("code",[e._v("UnaryFunction<T>")]),e._v(") generates an unchecked cast warning, as "),a("code",[e._v("UnaryOperator<Object>")]),e._v(" is not a "),a("code",[e._v("UnaryOperator<T>")]),e._v(" for every T. But the identity function is special: it returns its argument unmodified, so we know that it is typesafe to use it as a "),a("code",[e._v("UnaryFunction<T>")]),e._v(", whatever the value of T. Therefore, we can confidently suppress the unchecked cast warning generated by this cast. Once we’ve done this, the code compiles without error or warning.")]),e._v(" "),a("p",[e._v("IDENTITY_FN 到（"),a("code",[e._v("UnaryFunction<T>")]),e._v("）的转换会生成一个 unchecked 转换警告，因为 "),a("code",[e._v("UnaryOperator<Object>")]),e._v(" 并不是每个 T 都是 "),a("code",[e._v("UnaryOperator<T>")]),e._v("，但是恒等函数是特殊的：它会返回未修改的参数，所以我们知道，无论 T 的值是多少，都可以将其作为 "),a("code",[e._v("UnaryFunction<T>")]),e._v(" 使用，这是类型安全的。一旦我们这样做了，代码编译就不会出现错误或警告。")]),e._v(" "),a("p",[e._v("Here is a sample program that uses our generic singleton as a "),a("code",[e._v("UnaryOperator<String>")]),e._v(" and a "),a("code",[e._v("UnaryOperator<Number>")]),e._v(". As usual, it contains no casts and compiles without errors or warnings:")]),e._v(" "),a("p",[e._v("下面是一个示例程序，它使用我们的泛型单例作为 "),a("code",[e._v("UnaryOperator<String>")]),e._v(" 和 "),a("code",[e._v("UnaryOperator<Number>")]),e._v("。像往常一样，它不包含类型转换和编译，没有错误或警告：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// Sample program to exercise generic singleton\npublic static void main(String[] args) {\n    String[] strings = { "jute", "hemp", "nylon" };\n    UnaryOperator<String> sameString = identityFunction();\n\n    for (String s : strings)\n        System.out.println(sameString.apply(s));\n\n    Number[] numbers = { 1, 2.0, 3L };\n    UnaryOperator<Number> sameNumber = identityFunction();\n\n    for (Number n : numbers)\n        System.out.println(sameNumber.apply(n));\n}\n')])])]),a("p",[e._v("It is permissible, though relatively rare, for a type parameter to be bounded by some expression involving that type parameter itself. This is what’s known as a recursive type bound. A common use of recursive type bounds is in connection with the Comparable interface, which defines a type’s natural ordering (Item 14). This interface is shown here:")]),e._v(" "),a("p",[e._v("允许类型参数被包含该类型参数本身的表达式限制，尽管这种情况比较少见。这就是所谓的递归类型限定。递归类型边界的一个常见用法是与 Comparable 接口相关联，后者定义了类型的自然顺序（Item-14）。该界面如下图所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public interface Comparable<T> {\n    int compareTo(T o);\n}\n")])])]),a("p",[e._v("The type parameter T defines the type to which elements of the type implementing "),a("code",[e._v("Comparable<T>")]),e._v(" can be compared. In practice, nearly all types can be compared only to elements of their own type. So, for example, String implements "),a("code",[e._v("Comparable<String>")]),e._v(", Integer implements "),a("code",[e._v("Comparable<Integer>")]),e._v(", and so on.")]),e._v(" "),a("p",[e._v("类型参数 T 定义了实现 "),a("code",[e._v("Comparable<T>")]),e._v(" 的类型的元素可以与之进行比较的类型。在实践中，几乎所有类型都只能与它们自己类型的元素进行比较。例如，String 实现 "),a("code",[e._v("Comparable<String>")]),e._v("， Integer 实现 "),a("code",[e._v("Comparable<Integer>")]),e._v("，等等。")]),e._v(" "),a("p",[e._v("Many methods take a collection of elements implementing Comparable to sort it, search within it, calculate its minimum or maximum, and the like. To do these things, it is required that every element in the collection be comparable to every other element in it, in other words, that the elements of the list be mutually comparable. Here is how to express that constraint:")]),e._v(" "),a("p",[e._v("许多方法采用实现 Comparable 的元素集合，在其中进行搜索，计算其最小值或最大值，等等。要做到这些，需要集合中的每个元素与集合中的每个其他元素相比较，换句话说，就是列表中的元素相互比较。下面是如何表达这种约束（的示例）：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Using a recursive type bound to express mutual comparability\npublic static <E extends Comparable<E>> E max(Collection<E> c);\n")])])]),a("p",[e._v("The type bound "),a("code",[e._v("<E extends Comparable<E>>")]),e._v(" may be read as “any type E that can be compared to itself,” which corresponds more or less precisely to the notion of mutual comparability.")]),e._v(" "),a("p",[e._v("类型限定 "),a("code",[e._v("<E extends Comparable<E>>")]),e._v(" 可以被理解为「可以与自身进行比较的任何类型 E」，这或多或少与相互可比性的概念相对应。")]),e._v(" "),a("p",[e._v("Here is a method to go with the previous declaration. It calculates the maximum value in a collection according to its elements’ natural order, and it compiles without errors or warnings:")]),e._v(" "),a("p",[e._v("下面是一个与前面声明相同的方法。它根据元素的自然顺序计算集合中的最大值，编译时没有错误或警告：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// Returns max value in a collection - uses recursive type bound\npublic static <E extends Comparable<E>> E max(Collection<E> c) {\n    if (c.isEmpty())\n        throw new IllegalArgumentException("Empty collection");\n\n    E result = null;\n\n    for (E e : c)\n        if (result == null || e.compareTo(result) > 0)\n\n    result = Objects.requireNonNull(e);\n    return result;\n}\n')])])]),a("p",[e._v("Note that this method throws IllegalArgumentException if the list is empty. A better alternative would be to return an "),a("code",[e._v("Optional<E>")]),e._v(" (Item 55).")]),e._v(" "),a("p",[e._v("注意，如果列表为空，该方法将抛出 IllegalArgumentException。更好的选择是返回一个 "),a("code",[e._v("Optional<E>")]),e._v("（Item-55）。")]),e._v(" "),a("p",[e._v("Recursive type bounds can get much more complex, but luckily they rarely do. If you understand this idiom, its wildcard variant (Item 31), and the simulated self-type idiom (Item 2), you’ll be able to deal with most of the recursive type bounds you encounter in practice.")]),e._v(" "),a("p",[e._v("递归类型限定可能会变得复杂得多，但幸运的是，这种情况很少。如果你理解这个习惯用法、它的通配符变量（Item-31）和模拟的自类型习惯用法（Item-2），你就能够处理在实践中遇到的大多数递归类型限定。")]),e._v(" "),a("p",[e._v("In summary, generic methods, like generic types, are safer and easier to use than methods requiring their clients to put explicit casts on input parameters and return values. Like types, you should make sure that your methods can be used without casts, which often means making them generic. And like types, you should generify existing methods whose use requires casts. This makes life easier for new users without breaking existing clients (Item 26).")]),e._v(" "),a("p",[e._v("总之，与要求客户端对输入参数和返回值进行显式转换的方法相比，泛型方法与泛型一样，更安全、更容易使用。与类型一样，你应该确保你的方法可以在不使用类型转换的情况下使用，这通常意味着要使它们具有通用性。与类型类似，你应该将需要强制类型转换的现有方法泛型化。这使得新用户在不破坏现有客户端的情况下更容易使用（Item-26）。")])])},[],!1,null,null,null);t.default=r.exports}}]);