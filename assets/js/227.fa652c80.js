(window.webpackJsonp=window.webpackJsonp||[]).push([[227],{424:function(a,t,r){"use strict";r.r(t);var _=r(0),e=Object(_.a)({},function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"《java-8-函数式编程》"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#《java-8-函数式编程》","aria-hidden":"true"}},[a._v("#")]),a._v(" 《Java 8 函数式编程》")]),a._v(" "),r("h2",{attrs:{id:"书评"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#书评","aria-hidden":"true"}},[a._v("#")]),a._v(" 书评")]),a._v(" "),r("h2",{attrs:{id:"第-1-章-简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第-1-章-简介","aria-hidden":"true"}},[a._v("#")]),a._v(" 第 1 章 简介")]),a._v(" "),r("p",[a._v("大多数程序都跑在功能强大的多核 CPU 的机器上。")]),a._v(" "),r("p",[a._v("多核 CPU 的兴起成为了不容回避的事实。涉及锁的编程算法不但容易出错，而且耗费时间。")]),a._v(" "),r("p",[a._v("开发类库的程序员使用 Java 时，发现抽象级别还不够。")]),a._v(" "),r("p",[a._v("——增加 Lambda 表达式")]),a._v(" "),r("h2",{attrs:{id:"第-2-章-lambda-表达式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第-2-章-lambda-表达式","aria-hidden":"true"}},[a._v("#")]),a._v(" 第 2 章 Lambda 表达式")]),a._v(" "),r("p",[a._v("ThreadLocal")]),a._v(" "),r("h2",{attrs:{id:"第-3-章-流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第-3-章-流","aria-hidden":"true"}},[a._v("#")]),a._v(" 第 3 章 流")]),a._v(" "),r("p",[a._v("判断一个操作是惰性求值还是及早求值很简单：只需看它的返回值。如果返回值是 Stream，那么是惰性求值；如果返回值是另一个值或 为空，那么就是及早求值。")]),a._v(" "),r("h3",{attrs:{id:"_3-3-常用的流操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-常用的流操作","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.3 常用的流操作")]),a._v(" "),r("ul",[r("li",[a._v("3.3.1 collect(toList)")]),a._v(" "),r("li",[a._v("3.3.2 map")]),a._v(" "),r("li",[a._v("3.3.3 filter")]),a._v(" "),r("li",[a._v("3.3.4 flatMap")]),a._v(" "),r("li",[a._v("3.3.5 max 和 min")]),a._v(" "),r("li",[a._v("3.3.6 通用模式")]),a._v(" "),r("li",[a._v("3.3.7 reduce 模式")]),a._v(" "),r("li",[a._v("3.3.8 整合操作")])]),a._v(" "),r("h2",{attrs:{id:"第-4-章-类库"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第-4-章-类库","aria-hidden":"true"}},[a._v("#")]),a._v(" 第 4 章 类库")]),a._v(" "),r("h3",{attrs:{id:"_4-2-基本类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-基本类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.2 基本类型")]),a._v(" "),r("p",[a._v("在 Java 8 中，仅对整型、长整型和双浮点型做了特殊处理，因为他们在数值计算中用得最多，特殊处理后的系统性能提升效果最明显。")]),a._v(" "),r("h3",{attrs:{id:"_4-6-默认方法-4-7-多重继承"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-默认方法-4-7-多重继承","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.6 默认方法 & 4.7 多重继承")]),a._v(" "),r("p",[a._v("三定律")]),a._v(" "),r("ol",[r("li",[a._v("类胜于接口。如果在继承链中有方法体或抽象的方法声明，那么就可以忽略接口中定义的方法。")]),a._v(" "),r("li",[a._v("子类胜于父类。如果一个接口继承了另一个接口，且两个接口都定义了一个默认方法，那么子类中定义的方法胜出。")]),a._v(" "),r("li",[a._v("没有规则三。如果上面两条规则不适用，子类要么需要实现该方法，要么将该方法声明为抽象方法。")])]),a._v(" "),r("p",[a._v("其中第一条规则是为了让代码向后兼容。")]),a._v(" "),r("h3",{attrs:{id:"_4-10-optional"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-10-optional","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.10 Optional")]),a._v(" "),r("h2",{attrs:{id:"第-5-章-高级集合类和收集器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第-5-章-高级集合类和收集器","aria-hidden":"true"}},[a._v("#")]),a._v(" 第 5 章 高级集合类和收集器")]),a._v(" "),r("h3",{attrs:{id:"_5-1-方法引用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-方法引用","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.1 方法引用")]),a._v(" "),r("h3",{attrs:{id:"_5-2-元素顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-元素顺序","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.2 元素顺序")]),a._v(" "),r("h2",{attrs:{id:"第-6-章-数据并行化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第-6-章-数据并行化","aria-hidden":"true"}},[a._v("#")]),a._v(" 第 6 章 数据并行化")]),a._v(" "),r("h3",{attrs:{id:"_6-1-并行和并发"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-并行和并发","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.1 并行和并发")]),a._v(" "),r("p",[a._v("并发和并行是两个不同的概念。")]),a._v(" "),r("p",[a._v("并发是两个任务共享时间段，并行则是两个任务在同一时间发生，比如运行在多核 CPU 上。如果一个程序要运行两个任务，并且只有一个 CPU 给他们分配了不同的时间片，那么这就是并发，而不是并行。")]),a._v(" "),r("p",[a._v("并行化是指为缩短任务执行时间，将一个任务分解成几部分，然后并行执行。这和顺序执行的任务量是一样的，区别就像用更多的马来拉车，花费的时间自然减少了。实际上，和顺序执行相比，并行化执行任务时，CPU 承载的工作量更大。")]),a._v(" "),r("h2",{attrs:{id:"第-7-章-测试、调试和重构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第-7-章-测试、调试和重构","aria-hidden":"true"}},[a._v("#")]),a._v(" 第 7 章 测试、调试和重构")]),a._v(" "),r("h2",{attrs:{id:"第-8-章-设计和架构的原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第-8-章-设计和架构的原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 第 8 章 设计和架构的原则")]),a._v(" "),r("h3",{attrs:{id:"_8-1-lambda-表达式改变了设计模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-lambda-表达式改变了设计模式","aria-hidden":"true"}},[a._v("#")]),a._v(" 8.1 Lambda 表达式改变了设计模式")]),a._v(" "),r("ul",[r("li",[a._v("8.1.1 命令者模式")]),a._v(" "),r("li",[a._v("8.1.2 策略模式")]),a._v(" "),r("li",[a._v("8.1.3 观察者模式")]),a._v(" "),r("li",[a._v("8.1.4 模板方法模式")])]),a._v(" "),r("h2",{attrs:{id:"第-9-章-使用-lambda-表达式编写并打程序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第-9-章-使用-lambda-表达式编写并打程序","aria-hidden":"true"}},[a._v("#")]),a._v(" 第 9 章 使用 Lambda 表达式编写并打程序")]),a._v(" "),r("h2",{attrs:{id:"第-10-章-下一步该怎么办"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第-10-章-下一步该怎么办","aria-hidden":"true"}},[a._v("#")]),a._v(" 第 10 章 下一步该怎么办")])])},[],!1,null,null,null);t.default=e.exports}}]);