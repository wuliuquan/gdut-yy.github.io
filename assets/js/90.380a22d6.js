(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{331:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"附录a：动态作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#附录a：动态作用域","aria-hidden":"true"}},[t._v("#")]),t._v(" 附录A：动态作用域")]),t._v(" "),a("p",[t._v("在第二章中，作为与 JavaScript 中（事实上，其他大多数语言也是）作用域的工作方式模型 —— “词法作用域”的对比，我们谈到了“动态作用域”。")]),t._v(" "),a("p",[t._v("我们将简单地检视动态作用域，来彻底说明这种比较。但更重要的是，对于 JavaScript 中的另一种机制（"),a("code",[t._v("this")]),t._v("）来说动态作用域实际上是它的一个近亲表兄，我们将在本系列的“"),a("em",[t._v("this与对象原型")]),t._v("”中详细讲解这种机制。")]),t._v(" "),a("p",[t._v("正如我们在第二章中看到的，词法作用域是一组关于 "),a("em",[t._v("引擎")]),t._v(" 如何查询变量和它在何处能够找到变量的规则。词法作用域的关键性质是，它是在代码编写时被定义的（假定你不使用 "),a("code",[t._v("eval()")]),t._v(" 或 "),a("code",[t._v("with")]),t._v(" 作弊的话）。")]),t._v(" "),a("p",[t._v("动态作用域看起来在暗示，有充分的理由，存在这样一种模型，它的作用域是在运行时被确定的，而不是在编写时静态地确定的。让我们通过代码来说明这样的实际情况：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("在 "),a("code",[t._v("foo()")]),t._v(" 的词法作用域中指向 "),a("code",[t._v("a")]),t._v(" 的 RHS 引用将被解析为全局变量 "),a("code",[t._v("a")]),t._v("，它将导致输出结果为值 "),a("code",[t._v("2")]),t._v("。")]),t._v(" "),a("p",[t._v("相比之下，动态作用域本身不关心函数和作用域是在哪里和如何被声明的，而是关心 "),a("strong",[t._v("它们是从何处被调用的")]),t._v("。换句话说，它的作用域链条是基于调用栈的，而不是代码中作用域的嵌套。")]),t._v(" "),a("p",[t._v("所以，如果 JavaScript 拥有动态作用域，当 "),a("code",[t._v("foo()")]),t._v(" 被执行时，"),a("strong",[t._v("理论上")]),t._v(" 下面的代码将得出 "),a("code",[t._v("3")]),t._v(" 作为输出结果。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3  (不是 2!)")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("这怎么可能？因为当 "),a("code",[t._v("foo()")]),t._v(" 不能为 "),a("code",[t._v("a")]),t._v(" 解析出一个变量引用时，它不会沿着嵌套的（词法）作用域链向上走一层，而是沿着调用栈向上走，以找到 "),a("code",[t._v("foo()")]),t._v(" 是 "),a("em",[t._v("从何处")]),t._v(" 被调用的。因为 "),a("code",[t._v("foo()")]),t._v(" 是从 "),a("code",[t._v("bar()")]),t._v(" 中被调用的，它就会在 "),a("code",[t._v("bar()")]),t._v(" 的作用域中检查变量，并且在这里找到持有值 "),a("code",[t._v("3")]),t._v(" 的 "),a("code",[t._v("a")]),t._v("。")]),t._v(" "),a("p",[t._v("奇怪吗？此时此刻你可能会这样认为。")]),t._v(" "),a("p",[t._v("但这可能只是因为你仅在拥有词法作用域的代码中工作过。所以动态作用域看起来陌生。如果你仅使用动态作用域的语言编写过代码，它看起来就是很自然的，而词法作用域将是个怪东西。")]),t._v(" "),a("p",[t._v("要清楚，JavaScript "),a("strong",[t._v("实际上没有动态作用域")]),t._v("。它拥有词法作用域。就这么简单。但是 "),a("code",[t._v("this")]),t._v(" 机制有些像动态作用域。")]),t._v(" "),a("p",[t._v("关键的差异："),a("strong",[t._v("词法作用域是编写时的，而动态作用域（和 "),a("code",[t._v("this")]),t._v("）是运行时的")]),t._v("。词法作用域关心的是 "),a("em",[t._v("函数在何处被声明")]),t._v("，但是动态作用域关心的是函数 "),a("em",[t._v("从何处")]),t._v(" 被调用。")]),t._v(" "),a("p",[t._v("最后："),a("code",[t._v("this")]),t._v(" 关心的是 "),a("em",[t._v("函数是如何被调用的")]),t._v("，这揭示了 "),a("code",[t._v("this")]),t._v(" 机制与动态作用域的想法有多么紧密的关联。要了解更多关于 "),a("code",[t._v("this")]),t._v(" 的细节，请阅读 “"),a("em",[t._v("this与对象原型")]),t._v("”。")])])},[],!1,null,null,null);s.default=e.exports}}]);